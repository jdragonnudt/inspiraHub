<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="jdragon">
<meta name="dcterms.date" content="2024-09-28">

<title>数智启思 - 什么是计算？</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">数智启思</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../AIengineerBook/index.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../myblog/index.html"> 
<span class="menu-text">Blogs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
    <a href="https://github.com/jdragonnudt/inspiraHub" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">什么是计算？</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">计算学科</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>jdragon </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 28, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#一计算的概念是什么" id="toc-一计算的概念是什么" class="nav-link active" data-scroll-target="#一计算的概念是什么">一、计算的概念是什么？</a></li>
  <li><a href="#二计算概念的发展" id="toc-二计算概念的发展" class="nav-link" data-scroll-target="#二计算概念的发展">二、计算概念的发展</a>
  <ul class="collapse">
  <li><a href="#一计算学科诞生前的计算" id="toc-一计算学科诞生前的计算" class="nav-link" data-scroll-target="#一计算学科诞生前的计算">(一)计算学科诞生前的计算</a></li>
  <li><a href="#二图灵认为的计算" id="toc-二图灵认为的计算" class="nav-link" data-scroll-target="#二图灵认为的计算">(二)图灵认为的计算</a></li>
  <li><a href="#三信息论概念下的计算" id="toc-三信息论概念下的计算" class="nav-link" data-scroll-target="#三信息论概念下的计算">(三)信息论概念下的计算</a></li>
  <li><a href="#四计算学科意义下的计算" id="toc-四计算学科意义下的计算" class="nav-link" data-scroll-target="#四计算学科意义下的计算">(四)计算学科意义下的计算</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>计算这个术语，当前已经成为最被人所熟知的一个。从大学计算机专业、社会上的计算机产业到我们几乎人手一台的计算机，到处都可以看到计算这个词。但这个词，可能又是我们最熟悉的陌生人，要具体说一下这个词的含义，好像又很难说得清楚。</p>
<p>计算机，顾名思义，计算的机器。那么什么是计算呢？看起来，计算应该是数学中对数的加减乘除这样的概念，但是，现代计算机可以做的似乎直观上不只是做加减乘除，而是可以播放视频、构造可以处理业务数据的软件、智能管理城市等等。而且计算机专业的学生编程是怎么回事？明明学的是计算机，为什么又在学习编程？编程和计算是什么关系？</p>
<p>那么像播放视频、处理业务数据这些能力是不是就不是计算呢？如果不是的话？那么计算机是用来计算的机器这个说法是不是就不对了呢？</p>
<p>让我们查查词典吧。</p>
<p>计算，英文单词是computation，在《柯林斯高阶英汉双解学习词典》第393页这样描述：“computation is mathematical calculation.”</p>
<p>也就是说，计算是一种”mathematical calculation”。mathematical是数学的，那么什么又是calculation呢。《柯林斯高阶英汉双解学习词典》第269页这样描述：“calculation：A calculation is something that you think about and work out mathematically. calculation is the process of working something out mathematically.”</p>
<p>看起来，好像computation和calculation相互循环定义了，实际谁也没有把谁说清楚。</p>
<p>但从词典的解释看起来，有一点是可以肯定的，那就是，计算是和数学密切相关的。那我们接下来就仔细梳理一遍这些概念。</p>
<section id="一计算的概念是什么" class="level2">
<h2 class="anchored" data-anchor-id="一计算的概念是什么">一、计算的概念是什么？</h2>
<p>从朴素的含义讲，我们从小学一年级起，就要学习计算。这时的计算，就是对数做加减等操作，当然，后面的操作方式越来越丰富，不光是加、减，还出现了乘、除、乘方、开方等。操作的对象，数，也在不断地扩大范围，最开始是自然数，然后是整数、再到有理数、实数、虚数等等。那么，针对这些数集的加、减、乘、除、乘方、开方等操作都是计算。</p>
<p>然而，这个朴素的含义应该是不准确的，这些数集还能继续扩展吗？除了这些数集以外，还有别的对象可以作为计算操作的对象吗？另外，这些操作的方式还能扩展吗？除了这些操作方式外，还有别的操作方式吗？究竟完整的计算定义是什么？</p>
<p>而到了现在，计算的含义发生了变化。《计算机科学技术百科全书》第二版里，专门对计算机做了一段描述。它提到，计算机是一种现代化的信息处理工具。信息是对数据所赋予的涵义，数据是对象的表示，无含义。处理可理解为变换。计算机对信息进行处理，并提供处理结果。</p>
<p>不难看出，现代的计算含义变成了信息处理，也即对信息进行变换。那么，究竟发生了什么，使得现代的计算和最初的计算有如此巨大的含义变化？</p>
</section>
<section id="二计算概念的发展" class="level2">
<h2 class="anchored" data-anchor-id="二计算概念的发展">二、计算概念的发展</h2>
<p>数学作为一门古老而基础的学科，其发展历程与计算方法的创新和演进紧密相连。从古代的算术、几何到现代的代数、微积分，数学理论的不断丰富和完善为计算提供了坚实的理论基础，推动了计算方法的创新和发展。</p>
<section id="一计算学科诞生前的计算" class="level3">
<h3 class="anchored" data-anchor-id="一计算学科诞生前的计算">(一)计算学科诞生前的计算</h3>
<p>在《数学简史》（牛津读本）第二章中，追溯了中文”算”字的含义。它提到，“算”做名词可以表示一组用木头、金属或象牙制成的短棒，人们在平面上熟练地操作这些短棒来标记计算中的数字。，“算”字一字也可以表示用短棒进行计算的行为。</p>
<p>“算”和“历”时常有着联系，同时，“算”与更多的世俗事务、利润计算以及资源分配有关。</p>
<p>以下就描述了计算学科诞生前计算概念的发展。</p>
<section id="古代的计算工具和方法" class="level4">
<h4 class="anchored" data-anchor-id="古代的计算工具和方法">1.古代的计算工具和方法</h4>
<p>古代，人类在面对复杂的计数与计算需求时，展现出了非凡的智慧与创造力，发明并广泛使用了多种计算工具与方法。这些早期的计算手段不仅解决了日常生活中的实际问题，如贸易结算、天文观测及建筑工程等，还为后世计算学科的发展奠定了坚实的基础，其影响深远且持久。</p>
<section id="算盘全球范围内的普及与影响" class="level5">
<h5 class="anchored" data-anchor-id="算盘全球范围内的普及与影响">算盘：全球范围内的普及与影响</h5>
<p>算盘，作为最为人熟知的古代计算工具之一，其历史可追溯至数千年前。在不同文化中，算盘的形式各异，但原理大致相同，即通过算珠的不同排列组合来表示数值并进行计算。中国的传统算盘以其结构简单、运算高效而著称，由木框、细杆及串挂的算珠组成，分为上下两部分，分别用于个、十、百等不同数位的运算。欧洲的算盘则多采用金属制成，形态更为多样化。算盘的使用极大地提高了计算效率，是古代商业活动中不可或缺的工具，同时也促进了数学理论的发展，尤其是在分数运算和比例计算方面。</p>
</section>
<section id="计数棒与计数板原始的直观表达" class="level5">
<h5 class="anchored" data-anchor-id="计数棒与计数板原始的直观表达">计数棒与计数板：原始的直观表达</h5>
<p>在算盘之前，人们普遍采用更为原始的计数工具，如计数棒（Counting Sticks）和计数板（Counting Boards）。这些工具通常由石头、骨头或木材制成，通过在特定位置摆放或刻画记号来表示数量。古埃及人和美索不达米亚人就广泛使用这类工具进行日常交易和记录。虽然它们的操作不如算盘灵活，但在那个时代，它们提供了一种直观且易于理解的计数方式，帮助古人有效地管理资源和规划活动。</p>
</section>
<section id="结绳记事古老文明的记忆法" class="level5">
<h5 class="anchored" data-anchor-id="结绳记事古老文明的记忆法">结绳记事：古老文明的记忆法</h5>
<p>除了实物工具外，古代文明还创造了象征性的计数方法，其中最著名的莫过于“结绳记事”。这种方法通过在绳子上打结来记录事件或数量，每个结代表一个单位，不同颜色或位置的结可能代表不同的事物或等级。这种方法广泛应用于古代安第斯文明中，如印加帝国，用于记录税收、人口统计及历史事件等重要信息。结绳记事不仅是计算的一种形式，也是早期信息存储与传递的重要手段。</p>
</section>
<section id="数学文本与算法的早期发展" class="level5">
<h5 class="anchored" data-anchor-id="数学文本与算法的早期发展">数学文本与算法的早期发展</h5>
<p>随着时间的推移，古人开始将计算规则与方法记录下来，形成了早期的数学文本。例如，古巴比伦的泥板文书、古埃及的纸莎草文献以及古希腊数学家如欧几里得的著作，都包含了丰富的数学知识与计算技巧。这些文献不仅记录了基本的算术运算规则，还探讨了几何、代数等领域的问题，对后世数学体系的建立有着不可估量的贡献。特别是，它们展示了如何运用逻辑推理解决实际问题，为后来的算法设计提供了思想源泉。</p>
</section>
<section id="天文学与历法计算" class="level5">
<h5 class="anchored" data-anchor-id="天文学与历法计算">天文学与历法计算</h5>
<p>在古代，天文学的研究与历法的制定也是推动计算方法发展的重要因素。为了准确预测季节更替、制定农业历法以及进行宗教仪式，古人需要精密的天文观测与复杂的计算。比如，古埃及人通过观察尼罗河的涨落与星辰的位置来确定播种与收获的最佳时机；玛雅文明则创立了一套极为精确的历法系统，能够准确预测日食、月食等天文现象。这些活动促进了数学技巧的创新与应用，特别是在三角学和数理天文学方面。</p>
</section>
<section id="总结" class="level5">
<h5 class="anchored" data-anchor-id="总结">总结</h5>
<p>综上所述，古代的计算工具与方法体现了人类智慧的光辉，它们从简单的实物操作到复杂的理论体系，逐步构建起计算学科的雏形。这些早期的创新不仅解决了当时社会面临的实际问题，而且为后续数千年科技的进步开辟了道路。通过对古代计算工具与方法的研究，我们能够更好地理解现代计算技术的根基所在，以及它如何深刻地塑造了我们的世界。</p>
<p>通过前面的描述，大致可以看出，早期的计算，主要是对数学中的数进行各种数学运算。</p>
</section>
</section>
</section>
<section id="二图灵认为的计算" class="level3">
<h3 class="anchored" data-anchor-id="二图灵认为的计算">(二)图灵认为的计算</h3>
<p>进入现代，数学的发展更加迅速，新的数学分支和理论不断涌现。例如，线性代数、概率论和统计学等理论的发展为数据分析、机器学习等领域提供了重要的工具和方法。同时，数学与其他学科的交叉融合也促进了计算方法的创新和发展。例如，计算生物学、计算化学等新兴学科的出现，使得人们能够利用数学模型和算法来研究生物、化学反应等复杂系统。</p>
<p>图灵提出了图灵机的概念和原理，对现代计算机科学产生了重要影响。</p>
<section id="图灵机的概念和原理" class="level4">
<h4 class="anchored" data-anchor-id="图灵机的概念和原理">1.图灵机的概念和原理</h4>
<p>图灵机，作为现代计算机科学的理论基石，由英国数学家、逻辑学家、密码破译者及计算机科学的先驱艾伦·图灵于1936年提出。它不仅为理解计算的本质提供了一个数学模型，也为后续的计算机设计与发展奠定了坚实的理论基础。</p>
<section id="概念解析" class="level5">
<h5 class="anchored" data-anchor-id="概念解析">概念解析</h5>
<p>图灵机是一种抽象的机器，旨在模拟任何可被算法描述的过程。其核心组件包括：</p>
<ul>
<li><strong>无限长的纸带</strong>：纸带上划分为一系列连续的方格，每个方格中可以写入一个符号（通常为0或1），或者保持空白。</li>
<li><strong>读写头</strong>：能够在纸带上左右移动，读取当前位置的符号并根据预设的规则改写符号。</li>
<li><strong>状态寄存器</strong>：存储图灵机的当前状态，根据读入的符号和当前状态决定下一步动作（移动方向、写入符号及状态转换）。</li>
<li><strong>指令集</strong>：定义了在特定状态下遇到不同符号时的行为规则，包括状态转移、符号修改以及读写头的移动方向。</li>
</ul>
</section>
<section id="工作原理" class="level5">
<h5 class="anchored" data-anchor-id="工作原理">工作原理</h5>
<p>图灵机的工作循环可以概括为“读取-处理-写入”三个步骤：</p>
<ol type="1">
<li><strong>读取</strong>：读写头读取当前所在方格上的符号。</li>
<li><strong>处理</strong>：根据当前状态和读取到的符号，参照指令集确定下一步操作。</li>
<li><strong>写入与移动</strong>：根据指令，可能涉及更改当前方格的符号、改变状态以及向左或向右移动一个方格。</li>
</ol>
<p>这一过程不断重复，直到达到停机状态，即没有指令可执行，此时纸带上的内容即为计算的结果。</p>
</section>
<section id="理论意义" class="level5">
<h5 class="anchored" data-anchor-id="理论意义">理论意义</h5>
<p>图灵机之所以重要，在于它提供了一种通用的计算框架，证明了所有可计算问题都可以用图灵机来解决，只要给予足够的时间和资源。此外，图灵还提出了著名的“丘奇-图灵论题”，该论题表明，如果一个问题可以在任何通用计算模型上解决，那么它也可以用图灵机解决。这进一步巩固了图灵机作为理解计算本质的核心地位。</p>
</section>
<section id="对现代计算机科学的影响" class="level5">
<h5 class="anchored" data-anchor-id="对现代计算机科学的影响">对现代计算机科学的影响</h5>
<p>图灵机的概念直接启发了现代计算机的设计，特别是冯·诺依曼体系结构中的程序存储思想。同时，图灵机也是理解计算复杂性、自动机理论、形式语言等计算机科学基础领域的关键工具。更重要的是，图灵机的概念促进了对算法效率、计算能力边界以及人工智能可能性的深入探讨。</p>
<p>综上所述，图灵机不仅是一个理论上的抽象模型，更是连接数学、逻辑与实际计算机实现之间的桥梁，深刻影响了我们对计算本质的理解及其应用的发展。</p>
<p>这时，图灵的核心观点，认为计算就是对数学函数的求解。《伟大的计算原理》</p>
</section>
</section>
<section id="图灵机对现代计算机科学的影响" class="level4">
<h4 class="anchored" data-anchor-id="图灵机对现代计算机科学的影响">2.图灵机对现代计算机科学的影响</h4>
<p>图灵机的概念和原理为现代计算机科学的发展奠定了坚实的基础，其对编程语言、算法设计等多个方面产生了深远的影响。</p>
<p>首先，图灵机为理解计算的本质提供了一个精确的数学模型。通过定义一个抽象的机器，图灵展示了如何通过一系列简单的操作来执行复杂的计算任务。这种思想直接影响了编程语言的设计，使得程序可以被视为对图灵机的模拟，从而为编写可执行特定任务的代码提供了理论基础。</p>
<p>其次，图灵的工作引入了通用计算的概念，即存在一种机器（如图灵机）能够模拟任何其他机器的行为。这一概念是现代计算机体系结构的核心，它允许我们构建通用的计算机硬件，并通过编写不同的软件来实现各种功能。这种通用性是现代计算机区别于以往专用计算设备的关键特征。</p>
<p>此外，图灵还提出了著名的“图灵测试”，作为衡量机器是否具有智能的标准。虽然这个测试本身在哲学上存在争议，但它启发了人工智能领域的研究，推动了机器学习和自然语言处理等技术的发展。</p>
<p>在算法设计方面，图灵机的理论框架促使研究者探索更高效的算法来解决特定问题。例如，复杂性理论就是在图灵机的基础上发展起来的，它研究问题的固有难度以及不同算法解决问题的效率。这些理论不仅对理论研究有重要意义，也在实践中指导着软件开发和系统设计。</p>
<p>最后，图灵机的概念还影响了我们对计算极限的理解。通过研究图灵机无法解决的问题，科学家们发现了计算的基本限制，如停机问题的不可解性。这些发现对于理解计算的本质至关重要，并且对于设计安全的加密系统等领域有着实际应用价值。</p>
<p>综上所述，图灵机对现代计算机科学的影响是全方位的。从编程语言的设计到算法优化，从人工智能的研究到对计算极限的认识，图灵机的理论都在其中扮演着核心角色。</p>
</section>
</section>
<section id="三信息论概念下的计算" class="level3">
<h3 class="anchored" data-anchor-id="三信息论概念下的计算">(三)信息论概念下的计算</h3>
<p>信息论为计算学科提供了新的视角和方法，其在计算学科中的应用日益广泛。</p>
<section id="信息论的基本概念" class="level4">
<h4 class="anchored" data-anchor-id="信息论的基本概念">1.信息论的基本概念</h4>
<p>信息论是研究信息的传输、存储和处理的理论，其基本概念包括熵、互信息等。熵是信息论中的一个重要概念，它表示的是一个随机变量的不确定性程度。在信息论中，熵通常用来衡量一个信源产生的平均信息量。互信息则是衡量两个随机变量之间相互依赖性的度量，它可以反映两个随机变量之间的信息共享程度。</p>
<p>首先，我们来讨论熵。熵的定义如下：对于一个离散型随机变量X，其可能取值为x1, x2, …, xn，对应的概率分布为p1, p2, …, pn，则X的熵H(X)定义为：</p>
<p>H(X) = -Σ(pi * log2(pi))</p>
<p>其中，Σ表示求和，log2表示以2为底的对数。熵的单位是比特（bit），表示一个随机变量的平均信息量。熵越大，表示随机变量的不确定性越高，信息量越大；反之，熵越小，表示随机变量的不确定性越低，信息量越小。</p>
<p>接下来，我们来讨论互信息。互信息的定义如下：对于两个离散型随机变量X和Y，它们的联合概率分布为p(x, y)，边缘概率分布分别为p(x)和p(y)，则X和Y之间的互信息I(X; Y)定义为：</p>
<p>I(X; Y) = Σ(Σ(p(x, y) * log2(p(x, y) / (p(x) * p(y)))))</p>
<p>互信息的单位也是比特（bit），表示两个随机变量之间的信息共享程度。互信息越大，表示两个随机变量之间的依赖性越强，信息共享程度越高；反之，互信息越小，表示两个随机变量之间的依赖性越弱，信息共享程度越低。</p>
<p>总之，信息论的基本概念包括熵和互信息等，它们分别用来衡量随机变量的不确定性程度和两个随机变量之间的依赖性。这些概念在计算学科中的应用广泛，如数据压缩、信道编码、密码学等领域。通过对这些基本概念的研究，我们可以更好地理解和优化信息的传输、存储和处理过程。</p>
</section>
<section id="信息论在计算学科中的应用" class="level4">
<h4 class="anchored" data-anchor-id="信息论在计算学科中的应用">2.信息论在计算学科中的应用</h4>
<p>信息论，由克劳德·香农在20世纪中叶提出，是研究信息的量化、存储与传输的学科。它不仅为通信理论提供了坚实的数学基础，还在计算学科的多个领域内展现了其深远的影响力。</p>
<section id="数据压缩" class="level5">
<h5 class="anchored" data-anchor-id="数据压缩">数据压缩</h5>
<p>在数据压缩领域，信息论的核心思想是通过减少冗余信息来提高数据传输和存储的效率。霍夫曼编码（Huffman Coding）是一种广泛应用的数据压缩算法，基于字符出现频率的不同赋予不同长度的编码，从而实现整体数据的压缩。这种编码方法利用了信息熵的概念，即一个随机变量不确定性的度量，通过最小化平均编码长度来达到最优压缩效果。此外，算术编码（Arithmetic Coding）提供了另一种高效的压缩方式，它将整个消息映射到一个小于1的区间内的实数上，进一步逼近信息的熵极限。</p>
</section>
<section id="错误检测和纠正" class="level5">
<h5 class="anchored" data-anchor-id="错误检测和纠正">错误检测和纠正</h5>
<p>信息论在错误控制编码方面的应用同样不可或缺。循环冗余检查（CRC）是一种简单的错误检测方法，通过附加一些校验位到数据上来检查数据传输过程中的错误。而更复杂的纠错码如里德-所罗门码（Reed-Solomon Codes）则能够检测并纠正错误，这在光盘存储和深空通信等领域尤为重要。这些技术背后的原理涉及到信息论中的冗余度和编码理论，通过增加额外的信息位来提高系统的鲁棒性。</p>
</section>
<section id="密码学" class="level5">
<h5 class="anchored" data-anchor-id="密码学">密码学</h5>
<p>在密码学领域，信息论的应用尤为关键。香农的《通信的数学理论》奠定了现代密码学的理论基础。公钥加密体系如RSA算法的安全性就是建立在大整数分解这一数论难题上的，而这一问题的难度可以通过信息论中的熵概念来描述。此外，信息论还为数字签名和认证协议提供了理论支撑，确保了电子交易和通信的安全性。</p>
</section>
<section id="量子计算与信息论" class="level5">
<h5 class="anchored" data-anchor-id="量子计算与信息论">量子计算与信息论</h5>
<p>随着量子计算的发展，信息论的研究也进入了新的阶段。量子比特（qubits）的叠加和纠缠特性使得量子信息处理成为可能，这为信息论带来了新的挑战和机遇。量子纠错码和量子密钥分发等技术都是基于量子信息论的研究进展，它们对于构建未来的量子互联网至关重要。</p>
<p>综上所述，信息论在计算学科中的应用广泛而深入，从数据压缩到错误控制，再到密码学和新兴的量子信息技术，信息论的原理和方法都在推动着计算技术的革新和发展。随着技术的不断进步，信息论的理论和应用将继续扩展其在计算学科中的影响范围。</p>
</section>
</section>
</section>
<section id="四计算学科意义下的计算" class="level3">
<h3 class="anchored" data-anchor-id="四计算学科意义下的计算">(四)计算学科意义下的计算</h3>
<p>计算学科的定义和发展反映了人们对计算本质的理解不断深化，其研究内容和方法也日益丰富。</p>
<p><img src="thumbnail.jpg" class="img-fluid"></p>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="jdragonnudt/inspiraHub" data-repo-id="R_kgDOMGN2Lg" data-category="General" data-category-id="DIC_kwDOMGN2Ls4Cf8Yq" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2024, by jdragon. 本网站所有内容采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA许可，知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>